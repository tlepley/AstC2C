/*
  This file is part of AstC2C.
  
  Authors: Monty Zukoski, Thierry Lepley
*/

package ir.base;


import ir.literals.*;
import ir.symboltable.*;
import ir.symboltable.symbols.Symbol;
import ir.types.Type;

import antlr.collections.AST;
import antlr.CommonAST;
import antlr.Token;
import java.lang.reflect.*;
import java.util.HashMap;
import java.util.Map;
import java.util.Iterator;

/** 
  Class TNode is an implementation of the AST interface
  and adds many useful features:

  It is double-linked for reverse searching.
  (this is currently incomplete, in that method doubleLink() must
  be called after any changes to the tree to maintain the 
  reverse links).

  It can store a definition node (defNode), so that nodes such
  as scoped names can refer to the node that defines the name.

  It stores line numbers for nodes.

  Searches for parents and children of a tree can be done
  based on their type.

  The tree can be printed to System.out using a lisp-style syntax.



 */
public class NodeAST extends CommonAST {
  protected int     ttype;
  protected String  text;
  protected Integer tokenNumber = null;
  protected int     lineNum = 0;
  protected String  source;
  protected Map<String,Object> attributes = null;
  
  private static InheritableThreadLocal<String> tokenVocabulary = new InheritableThreadLocal<String>() {
    @Override
    protected String initialValue() {
      return null;
    }
  };

  // Type of the node
  protected EnrichedType    data_type = null;


  /** Set the token vocabulary to a tokentypes class
      generated by antlr.
  */
  public static void setTokenVocabulary(String s) {
    tokenVocabulary.set(s);
  }

  //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  // Constructor
  //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  public NodeAST() {
  }


  public NodeAST(AST t) {
    super.initialize(t);
    initialize(t);
  }
  

  //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  // Method of the CommonAST interface
  //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  public void initialize(Token token) {
    CToken tok = (CToken) token;

    // Get token informations
    ttype       = tok.getType();
    text        = tok.getText();
    tokenNumber = new Integer(tok.getTokenNumber());

    // origin
    lineNum     = tok.getLine();
    source      = tok.getSource();
  }

  public void initialize(AST tr) {
    NodeAST t = (NodeAST) tr;

    // Copy informations
    ttype       = t.getType();
    text        = t.getText();
    tokenNumber = t.getTokenNumber(); // Integer immutable

    // origin
    lineNum     = t.getLineNum();
    source      = t.getSource();

    // Data type
    data_type    = t.getDataType();

    // Attributes
    if (t.attributes==null) {
      attributes=null;
    }
    else {
      attributes = new HashMap<String,Object>(t.attributes);
    }
  }


  /** Get the token type for this node */
  public int getType() {
    return ttype;
  }
  /** Set the token type for this node */
  public void setType(int ttype_) { 
    ttype = ttype_; 
  }

  /** Get the token text for this node */
  public String getText() {
    return text;
  }
  /** Set the token text for this node */
  public void setText(String text_) { 
    text = text_; 
  }

 /* Data type (for expressions) */
  public void setDataType(EnrichedType t) {
    data_type=t;
  }
  public EnrichedType getDataType() {
    return data_type;
  }



  //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  // Other Information
  //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  
  /** Get the line number for this node.
      - If the line number is 0, search for a non-zero line num
      among children */
  public int getLineNum() { 
    if (lineNum != 0) {
      return lineNum;
    }
    else {
      if(down == null) {
        return lineNum;
      }
      else {
        return ((NodeAST)down).getLocalLineNum();
      }
    }
  }
  
  /** Get the line number for this node.
      - If the line number is 0, search for a non-zero line num
      among children.
      - If no children, search for a non-zero line num among
      brothers */
  public int getLocalLineNum() { 
    if(lineNum != 0) {
      return lineNum; 
    }
    else {
      if(down == null) {
        if(right == null) {
          return lineNum; 
	}
        else {
          return ((NodeAST)right).getLocalLineNum();
	}
      }
      else {
        return ((NodeAST)down).getLocalLineNum();
      }
    }
  }
  
  /** Set the line number for this node */
  public void setLineNum(int lineNum_) { 
    lineNum = lineNum_; 
  }



  /** Return the source file of this node */
  public String getSource() { 
    return(source); 
  }
  /** Set the source file of this node */
  public void setSource(String source_) { 
    source = source_; 
  }


  /** Return the token number of this node */
  public Integer getTokenNumber() { 
    return(tokenNumber);
  }
  /** Set the token number of this node */
  public void setTokenNumber(Integer tokenNumber_) { 
    tokenNumber=tokenNumber_;
  }




  /** get the Map that holds attribute values.
   */  
  public Map<String,Object> getAttributesTable() {
    if(attributes == null) {
      attributes = new HashMap<String,Object>(7);
    }
    return(attributes);
  }
  /** lookup the attribute name in the attribute table.
    If the value does not exist, it returns null.
    */
  public Object getAttribute(String attrName) {
    if(attributes == null) {
      return(null);
    }
    else {
      return(attributes.get(attrName));
    }
  }
  /** lookup the attribute name in the attribute table.
    If the value does not exist, true.
    */
  public boolean isAttribute(String attrName) {
    if(attributes == null) {
      return(false);
    }
    else {
      return(attributes.containsKey(attrName));
    }
  }
  /** set an attribute in the attribute table.
   */
  public void setAttribute(String attrName, Object value) {
    if(attributes == null) {
      attributes = new HashMap<String,Object>(7);
    }
    attributes.put(attrName,value);
  }


  /** Set the 'literal' attribute  */
  public void setLiteral(Literal literal) {
    setAttribute("LITERAL",literal);
  }
  /** Get the 'literal' attribute if any */
  public Literal getLiteral() {
    return((Literal)getAttribute("LITERAL"));
  }
  /** Set the 'reference' attribute (reference to a symbol
      of the symbol table)  */
  public void setReference(Symbol symbol) {
    setAttribute("REFERENCE",symbol);
  }
  /** Get the 'reference' attribute (reference to a symbol
      of the symbol table) if any  */
  public Symbol getReference() {
    return((Symbol)getAttribute("REFERENCE"));
  }
  /** Set the 'definition' attribute (definition of a symbol
      of the symbol table)  */
  public void setDefinition(Symbol symbol) {
    setAttribute("DEFINITION",symbol);
  }
  /** Get the 'definition' attribute (definition of a symbol
      of the symbol table)  */
  public Symbol getDefinition() {
    return((Symbol)getAttribute("DEFINITION"));
  }



  //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  // Tree management
  //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


  
  /** return the last child of this node, or null if there is none */
  public NodeAST getLastChild() {
    NodeAST down = (NodeAST)getFirstChild();
    if(down != null) {
      return(down.getLastSibling());
    }
    else {
      return(null);
    }
  }

  /** return the last sibling of this node, which is 
      this if the next sibling is null */
  public NodeAST getLastSibling() {
    NodeAST next = (NodeAST)getNextSibling();
    if(next != null) {
      return(next.getLastSibling());
    }
    else {
      return(this);
    }
  }



  /** add the new node as a new sibling, inserting it ahead of any
    existing next sibling.  This method maintains double-linking.
    if node is null, nothing happens.  If the node has siblings, 
    then they are added in as well.
    */
  public void addSibling(AST node) {
    if(node == null) {
      return;
    }

    NodeAST next = (NodeAST)right;
    right = (NodeAST)node;
    NodeAST nodeLastSib = ((NodeAST)node).getLastSibling();
    nodeLastSib.right = next;
  }
  public void insertChild(NodeAST node) {
    if(node == null) {
      return;
    }
    node.right=down;
    down=node;
  }


 
  /** return the number of children of this node */
  public int numberOfChildren() {
    int count = 0;
    AST child = getFirstChild();
    while(child != null) {
      count++;
      child = child.getNextSibling();
    }
    return(count);
  }


  /** Change in the tree the line number
   */
 
  public void deepResetLineNum() {
    lineNum = 0;

    if(down != null) {
      ((NodeAST)down).deepResetLineNumWithRightSiblings();
    }
  }
  public void deepResetLineNumWithRightSiblings() {
    lineNum = 0;

    if(down != null) {
      ((NodeAST)down).deepResetLineNumWithRightSiblings();
    }
    if(right != null) {
      ((NodeAST)right).deepResetLineNumWithRightSiblings();
    }
  }
  public void deepSetLineNum(int l) {
    lineNum = l;

    if(down != null) {
      ((NodeAST)down).deepSetLineNum(l);
    }
  }
  public void deepSetLineNumWithRightSiblings(int l) {
    lineNum = l;

    if(down != null) {
      ((NodeAST)down).deepSetLineNumWithRightSiblings(l);
    }
    if(right != null) {
      ((NodeAST)right).deepSetLineNumWithRightSiblings(l);
    }
  }

  /** return a deep copy of this node, and all sub nodes.
    New tree is doubleLinked, with no parent or siblings.
    Marker value is not copied!
    */
  public NodeAST deepCopy() {
    NodeAST copy = new NodeAST();

    copy.ttype       = ttype;
    copy.text        = text;
    copy.lineNum     = lineNum;
    copy.source      = source;
    if (tokenNumber!=null) {
      copy.tokenNumber = new Integer(tokenNumber);
    }
    copy.data_type = data_type;

    if(attributes != null) {
      copy.attributes = new HashMap<String,Object>(attributes);
    }
    if(down != null) {
      copy.down = ((NodeAST)down).deepCopyWithRightSiblings();
    }

    return(copy);
  }


  /** return a deep copy of this node, all sub nodes,
    and right siblings. */
  public NodeAST deepCopyWithRightSiblings() {
    NodeAST copy = new NodeAST();

    copy.ttype       = ttype;
    copy.text        = text;
    copy.lineNum     = lineNum;
    copy.source      = source;
    if (tokenNumber!=null) {
      copy.tokenNumber = new Integer(tokenNumber);
    }
    copy.data_type = data_type;

    if(attributes != null) {
      copy.attributes = new HashMap<String,Object>(attributes);
    }
    if(down != null) {
      copy.down = ((NodeAST)down).deepCopyWithRightSiblings();
    }
    if(right != null) {
      copy.right = ((NodeAST)right).deepCopyWithRightSiblings();
    }

    return(copy);
  }


  /** return a short string representation of the node */
  public String toString() {
    StringBuffer str = new StringBuffer( getNameForType(getType()) +
					 "[" + getText() + ", " + "]");

    if(this.getLineNum() != 0) {
      str.append(" line:" + (this.getLineNum() ) );
    }

    if(this.getSource() != null) {
      str.append(" source:" + (this.getSource() ) );
    }

    // Data type of the node
    if (data_type!=null) {
      str.append( "TYPE: " + data_type.toString() + " " );
    }

    // Attributes
    if(attributes != null) {
      Iterator iter=attributes.entrySet().iterator();
      while (iter.hasNext()) {
	// Get Map informations
	Map.Entry entry = (Map.Entry)iter.next();
	str.append(" ").append(entry.getKey()).append(":")
	   .append(entry.getValue());
      }
    }

    return(str.toString());
  }




  /** print given tree to System.out */
  public static String emitTreeToString(AST t) {
    StringBuffer buff = new StringBuffer();

    if (t != null) {
      // Print the node content
      buff.append(t.getText());
      
      // Print the child list
      AST child1;
      child1 = t.getFirstChild();         
      if (child1 != null) {
	buff.append(emitASTNodeToString(child1));
      }
    }

    return buff.toString();
  }

  /** protected method that does the work of printing */
  protected static String emitASTNodeToString(AST t) {
    StringBuffer buff = new StringBuffer();

    // Print the node content
    buff.append(" "+t.getText());
    
    // Print the child tree
    AST child1;
    child1 = t.getFirstChild();         
    if (child1 != null) {
      buff.append(emitASTNodeToString(child1));
    }
    // Next in the sibling list
    AST next;
    next = t.getNextSibling();
    if(next != null) {
      buff.append(emitASTNodeToString(next));
    }

    return buff.toString();
  }


  /** print given tree to System.out */
  public static void printTree(AST t) {
       if (t == null) return;
       printASTNode(t,0);
       System.out.print("\n");
  }


  /** protected method that does the work of printing */
  protected static void printASTNode(AST t, int indent) {
    AST child1, next;
    child1 = t.getFirstChild();         
 
    System.out.print("\n");
    for(int i = 0; i < indent; i++) {
      System.out.print("   ");
    }

    if(child1 != null) {
      System.out.print("(");
    }

    String s = t.getText();
    if (s != null && s.length() > 0) {
      System.out.print(getNameForType(t.getType()));
      System.out.print(": \"" + s + "\"");
    }  
    else {
      System.out.print(getNameForType(t.getType()));
    }
    if (((NodeAST)t).getLineNum() != 0) {
      System.out.print(" line:" + ((NodeAST)t).getLineNum() );
    }

    if(((NodeAST)t).getSource() != null) {
      System.out.print(" source:" + (((NodeAST)t).getSource() ) );
    }


    // Data type of the node
    EnrichedType etype;
    etype=((NodeAST)t).getDataType();
    if (etype!=null) {
      System.out.print( "  TYPE: " + etype.toString() + " " );

      // Constant value
      if (etype.isConstantIntegral()) {
	System.out.print( "  VALUE: " + etype.getConstantIntegralValue() + " " );
      }
      else if (etype.isConstantFloatingpoint()) {
	System.out.print( "  VALUE: " + etype.getConstantFloatingpointValue() + " " );
      }
      else if (etype.isConstantLabel()) {
 	System.out.print( "  VALUE: <label> " );
      }
    }


    // Attributes
    if ( ((NodeAST)t).attributes != null ) {
      Iterator iter=((NodeAST)t).attributes.entrySet().iterator();
      while (iter.hasNext()) {
	// Get Map informations
	Map.Entry entry = (Map.Entry)iter.next();
	System.out.print(" " + entry.getKey() + ":" + entry.getValue());
      }
    }

    if (child1 != null) {
      printASTNode(child1,indent + 1);

      System.out.print("\n");
      for(int i = 0; i < indent; i++) {
	System.out.print("   ");
      }
      System.out.print(")");
    }

    next = t.getNextSibling();
    if(next != null) {
      printASTNode(next,indent);
    }
  }

  /** converts an int tree token type to a name.
      Does this by reflecting on nsdidl.IDLTreeTokenTypes,
      and is dependent on how ANTLR 2.00 outputs that class. */
  public static String getNameForType(int t) {
    try{
      Class c = Class.forName(tokenVocabulary.get());
      Field[] fields = c.getDeclaredFields();
      for (Field f : fields) {
	if (f.getInt(null)==t) {
	  return f.getName();
	}
      }
    } catch (Exception e) { e.printStackTrace(); }
    return("unfoundtype: " + t);
  }



  /** find the first child of the node 
    of the given type, return null on failure */
  public NodeAST firstChildOfType(int type) {
    NodeAST down = (NodeAST)getFirstChild();
    if(down == null) {
      return(null);
    }
    if(down.getType() == type) {
      return(down);
    }
    return(down.firstSiblingOfType(type));
  }

  /** find the first sibling of the node 
    of the given type, return null on failure */
  public NodeAST firstSiblingOfType(int type) {
    NodeAST right = (NodeAST)getNextSibling();
    if(right == null) {
      return(null);
    }
    if(right.getType() == type) {
      return(right);
    }
    return(right.firstSiblingOfType(type));
  }

}
